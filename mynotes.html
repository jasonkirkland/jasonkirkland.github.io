<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Pencil‑Only Notepad</title>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    :root { --bg: #0b0b0c; --ink: #f5f7fb; --panel: #16171a; --muted:#8c95a1; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji; }
    .app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr; }
    .toolbar { display: flex; gap: .5rem; align-items: center; padding: .5rem env(safe-area-inset-right) .5rem env(safe-area-inset-left); background: var(--panel); border-bottom: 1px solid #22252a; }
    .toolbar h1 { font-size: 1rem; font-weight: 600; margin: 0 .5rem 0 0; letter-spacing: .3px; color: var(--muted); }
    .toolbar button, .toolbar select, .toolbar input[type="range"] {
      -webkit-appearance: none; appearance: none; border: 1px solid #2a2e35; background: #1a1c20; color: var(--ink); border-radius: .6rem; padding: .5rem .7rem; font-size: .95rem; }
    .toolbar button:active { transform: translateY(1px); }
    .toolbar .spacer { flex: 1; }

    /* Canvas takes the remaining space */
    #stage { width: 100%; height: 100%; touch-action: none; display: block; background: #111214; }

    .hint { position: fixed; bottom: 8px; left: 50%; transform: translateX(-50%); color: var(--muted); font-size: .9rem; padding: .25rem .6rem; background: rgba(0,0,0,.35); border: 1px solid #23262b; border-radius: .6rem; -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); }
  </style>
</head>
<body>
  <div class="app">
    <div class="toolbar">
      <h1>Pencil‑Only Notepad</h1>
      <label>Size <input id="size" type="range" min="1" max="12" value="4" step="1" style="vertical-align: middle; width: 120px;" /></label>
      <select id="tool">
        <option value="pen" selected>Pen</option>
        <option value="eraser">Eraser</option>
      </select>
      <button id="clear">Clear</button>
      <div class="spacer"></div>
      <button id="save">Save PNG</button>
      <select id="accountMode" title="Pick Google account">
        <option value="ask">Choose account when saving…</option>
        <option value="sticky">Stick to last used account</option>
      </select>
      <label style="display:flex;gap:.4rem;align-items:center">
        <input id="autosave" type="checkbox" /> Auto-save
      </label>
      <button id="signin">Sign in / Switch account</button>
    </div>
    <canvas id="stage"></canvas>
  </div>
  <div class="hint">Only stylus input is accepted. Finger/palm won’t draw.</div>

  <script>
  (function() {
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

    let currentDpr = Math.max(1, window.devicePixelRatio || 1);

    function drawBackground() {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.globalCompositeOperation = 'destination-over';
      ctx.fillStyle = '#111214';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const lineSpacing = Math.max(28, Math.round(44 * currentDpr));
      const lineWidth = Math.max(1, Math.round(currentDpr));
      ctx.strokeStyle = 'rgba(245, 247, 251, 0.08)';
      ctx.lineWidth = lineWidth;
      for (let y = 0; y <= canvas.height; y += lineSpacing) {
        ctx.beginPath();
        ctx.moveTo(0, y + lineWidth / 2);
        ctx.lineTo(canvas.width, y + lineWidth / 2);
        ctx.stroke();
      }
      ctx.restore();
    }

    const sizeEl = document.getElementById('size');
    const toolEl = document.getElementById('tool');
    const clearBtn = document.getElementById('clear');
    const saveBtn = document.getElementById('save');

    let drawing = false;
    let lastX = 0, lastY = 0;

    // Match canvas to CSS size at devicePixelRatio for crisp strokes
    function resizeCanvas() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      currentDpr = dpr;
      const { width, height } = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(width * dpr));
      const h = Math.max(1, Math.floor(height * dpr));
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
      }
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // map CSS pixels → canvas
      // fill background
      drawBackground();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
    }

    function layout() {
      // Make canvas fill remaining viewport area below the toolbar
      const app = document.querySelector('.app');
      const rect = app.getBoundingClientRect();
      canvas.style.width = rect.width + 'px';
      canvas.style.height = (rect.height - app.querySelector('.toolbar').offsetHeight) + 'px';
      resizeCanvas();
    }

    window.addEventListener('resize', layout);
    window.addEventListener('orientationchange', () => setTimeout(layout, 50));
    layout();

    function isPencil(e) {
      return e.pointerType === 'pen';
    }

    function pressureWidth(e) {
      const base = parseFloat(sizeEl.value) || 4;
      // e.pressure is 0..1 on supporting devices (Apple Pencil reports it)
      const p = typeof e.pressure === 'number' && e.pressure > 0 ? e.pressure : 0.5;
      return base * (0.6 + p * 0.8); // subtle pressure variation
    }

    function setToolStyle(e) {
      if (toolEl.value === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = 'rgba(0,0,0,1)';
      } else {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = '#f5f7fb';
      }
      ctx.lineWidth = pressureWidth(e);
    }

    canvas.addEventListener('pointerdown', (e) => {
      if (!isPencil(e)) return; // ignore finger/palm/mouse
      drawing = true;
      setToolStyle(e);
      const rect = canvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      canvas.setPointerCapture(e.pointerId);
      e.preventDefault();
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!drawing || !isPencil(e)) return;
      setToolStyle(e);
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      // Simple smoothing
      const mx = (lastX + x) / 2;
      const my = (lastY + y) / 2;
      ctx.quadraticCurveTo(lastX, lastY, mx, my);
      ctx.stroke();
      lastX = x; lastY = y;
      if (toolEl.value === 'eraser') {
        drawBackground();
      }
      e.preventDefault();
    });

    function endStroke(e) {
      if (!drawing) return;
      drawing = false;
      try { canvas.releasePointerCapture(e.pointerId); } catch {}
      if (toolEl.value === 'eraser') {
        drawBackground();
      }
      e.preventDefault();
    }

    ['pointerup','pointercancel','pointerout','pointerleave'].forEach(t => {
      canvas.addEventListener(t, (e) => {
        if (!isPencil(e)) return; // only end when the pen ends
        endStroke(e);
      });
    });

    // Prevent touch gestures from interfering (panning/zooming), just in case
    ['touchstart','touchmove','touchend','touchcancel'].forEach(t => {
      canvas.addEventListener(t, ev => ev.preventDefault(), { passive: false });
    });

    // Toolbar actions
    clearBtn.addEventListener('click', () => {
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.restore();
      // redraw background after clear
      drawBackground();
    });

    saveBtn.addEventListener('click', () => {
      // Export at current resolution
      canvas.toBlob((blob) => {
        const a = document.createElement('a');
        a.download = 'note.png';
        a.href = URL.createObjectURL(blob);
        a.click();
        setTimeout(() => URL.revokeObjectURL(a.href), 1500);
      }, 'image/png');
    });

    // Optional: two-finger pinch to zoom is already disabled via touch-action:none
  })();
  </script>

  
  <script>
/** ---------- Google Drive wiring ---------- **/
const G_CLIENT_ID_PERSONAL = "1077396047895-gsq920fgfls71k8fmb6siqm8sc79dk3f.apps.googleusercontent.com";   // you can use one client for both accounts
const G_CLIENT_ID_WORK     = "YOUR_WORK_CLIENT_ID_IF_NEEDED"; // optional

// create (or reuse) a "Pencil Notes" folder and upload PNGs there.
const DRIVE_SCOPES = "https://www.googleapis.com/auth/drive.file";
let tokenClient, accessToken = null, activeClientId = G_CLIENT_ID_PERSONAL, activeAccountSub = null;

const ui = {
  autosave: document.getElementById('autosave'),
  accountMode: document.getElementById('accountMode'),
  signin: document.getElementById('signin'),
  saveBtn: document.getElementById('save'),
};

function initTokenClient(clientId = activeClientId) {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: clientId,
    scope: DRIVE_SCOPES,
    prompt: "", // empty = try silent if possible
    callback: (resp) => {
      if (resp && resp.access_token) {
        accessToken = resp.access_token;
        // Best-effort to identify the account; grab an ID token to read 'sub'
        google.accounts.oauth2.revoke(accessToken); // revoke previous cache if switching
      }
    }
  });
}

// Force the Google chooser (use when user taps “Sign in / Switch account”)
async function chooseAccount({ clientId = activeClientId } = {}) {
  return new Promise((resolve, reject) => {
    google.accounts.oauth2.initTokenClient({
      client_id: clientId,
      scope: DRIVE_SCOPES,
      prompt: "select_account", // <- shows the multi-account picker
      callback: (resp) => {
        if (resp && resp.access_token) {
          accessToken = resp.access_token;
          // We don’t get email directly; we can call OIDC userinfo to get a stable subject ("sub")
          fetch("https://www.googleapis.com/oauth2/v3/userinfo", {
            headers: { Authorization: "Bearer " + accessToken }
          })
          .then(r => r.json())
          .then(info => { activeAccountSub = info.sub; resolve(info); })
          .catch(() => resolve(null));
        } else reject(new Error("No token"));
      }
    }).requestAccessToken();
  });
}

// Get (or create) a folder by name, cache per-account
async function getOrCreateFolder(folderName = "Pencil Notes") {
  const cacheKey = `driveFolder_${folderName}_${activeAccountSub || "unknown"}`;
  const cached = localStorage.getItem(cacheKey);
  if (cached) return cached;

  const search = new URL("https://www.googleapis.com/drive/v3/files");
  search.searchParams.set("q", `mimeType='application/vnd.google-apps.folder' and name='${folderName.replaceAll("'", "\\'")}' and trashed=false`);
  search.searchParams.set("fields", "files(id,name)");

  let r = await fetch(search, { headers: { Authorization: "Bearer " + accessToken }});
  let j = await r.json();
  if (j.files && j.files.length) {
    localStorage.setItem(cacheKey, j.files[0].id);
    return j.files[0].id;
  }

  // Create folder
  r = await fetch("https://www.googleapis.com/drive/v3/files", {
    method: "POST",
    headers: { Authorization: "Bearer " + accessToken, "Content-Type": "application/json" },
    body: JSON.stringify({ name: folderName, mimeType: "application/vnd.google-apps.folder" })
  });
  j = await r.json();
  localStorage.setItem(cacheKey, j.id);
  return j.id;
}

// Upload PNG as a new file (timestamped)
// Uploads or overwrites a PNG file with the same name
async function uploadPNGtoDrive(blob, { folderId, filename }) {
  // Look for an existing file with the same name in the folder
  const search = new URL("https://www.googleapis.com/drive/v3/files");
  let q = `name='${filename.replaceAll("'", "\\'")}' and trashed=false`;
  if (folderId) q += ` and '${folderId}' in parents`;
  search.searchParams.set("q", q);
  search.searchParams.set("fields", "files(id,name)");

  const found = await fetch(search, { headers: { Authorization: "Bearer " + accessToken } })
    .then(r => r.json())
    .then(j => j.files?.[0]);

  const fileId = found?.id;
  const uploadUrl = fileId
    ? `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart&fields=id,name,webViewLink`
    : `https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,webViewLink`;

  const meta = { name: filename, parents: folderId ? [folderId] : undefined };
  const boundary = "-------314159265358979323846";
  const delimiter = "\r\n--" + boundary + "\r\n";
  const closeDelim = "\r\n--" + boundary + "--";

  const reader = await blob.arrayBuffer();
  const body =
    delimiter + "Content-Type: application/json; charset=UTF-8\r\n\r\n" +
    JSON.stringify(meta) +
    delimiter + "Content-Type: image/png\r\n" +
    "Content-Transfer-Encoding: base64\r\n\r\n" +
    btoa(String.fromCharCode(...new Uint8Array(reader))) +
    closeDelim;

  const resp = await fetch(uploadUrl, {
    method: fileId ? "PATCH" : "POST",
    headers: {
      Authorization: "Bearer " + accessToken,
      "Content-Type": "multipart/related; boundary=" + boundary
    },
    body
  });

  if (!resp.ok) throw new Error("Upload failed");
  return resp.json();
}


/** ---------- Hook into your existing canvas ---------- **/
const canvas = document.getElementById('stage');
// debounce helper
let saveTimer = null;
function scheduleAutoSave() {
  if (!ui.autosave.checked) return;
  if (saveTimer) clearTimeout(saveTimer);
  saveTimer = setTimeout(async () => {
    try {
      await ensureToken();
      const folderId = await getOrCreateFolder();
      const filename = "current_note.png";

      canvas.toBlob(async (blob) => {
        if (!blob) return;
        await uploadPNGtoDrive(blob, { folderId, filename });
        // optional: toast
        console.log("Auto-saved to Drive:", filename);
      }, "image/png");
    } catch (e) { console.warn(e); }
  }, 1200); // save ~1.2s after you stop drawing
}

async function ensureToken() {
  if (!accessToken) {
    // If user wants explicit choice each time, force chooser
    if (ui.accountMode.value === "ask") await chooseAccount({});
    else {
      initTokenClient(activeClientId);
      tokenClient.requestAccessToken(); // silent if possible
      await new Promise(r => setTimeout(r, 300)); // tiny delay to let callback set accessToken
    }
  }
}

// wire account switcher
ui.signin.addEventListener('click', async () => {
  // If you want to switch client IDs (e.g., to your work OAuth project), you can toggle here:
  // activeClientId = (activeClientId === G_CLIENT_ID_PERSONAL) ? G_CLIENT_ID_WORK : G_CLIENT_ID_PERSONAL;
  await chooseAccount({});
  alert("Signed in. Auto-save will use the selected account.");
});

// replace your existing "Save PNG" click to also offer Drive save
ui.saveBtn.addEventListener('click', async (e) => {
  // keep your current download behavior
  // then also offer Drive upload
  try {
    await ensureToken();
    const folderId = await getOrCreateFolder();
    const filename = "current_note.png";

    canvas.toBlob(async (blob) => {
      if (!blob) return;
      const res = await uploadPNGtoDrive(blob, { folderId, filename });
      alert("Saved to Google Drive:\n" + (res.webViewLink || res.name));
    }, "image/png");
  } catch (err) {
    alert("Drive save failed: " + err.message);
  }
});

// tie into your pen-up handler by appending:
['pointerup','pointercancel','pointerout','pointerleave'].forEach(t => {
  canvas.addEventListener(t, () => scheduleAutoSave(), { passive: true });
});
</script>

</body>
</html>
